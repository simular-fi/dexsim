"""
Example of non-atomic arbitrage between an external market (CEX) and a Uniswap pool
(usdc/dai).  The external price is synthetic data generated by Geometric Brownian Motion.

At each step the actor (bob) looks for price difference between the the 2 markets.
If the price on the external market is higher than the pool price by a given threshold,
bob will intentially push the pool price to the external market price via a calculated swap.

The tokens received from the pool swap can then be traded on the external market for (hopefully)
a profit.  The pool price will then be the same as the external market price.

There are a lot of variables that can impact how this works:  liquidity positions, liquidity
depth, how much money bob has, etc...
"""

import pandas as pd
import numpy as np
from dexsim import DEX, sqrtp_to_price


def gbm(mu: float, sigma: float, num_steps: int, rng: np.random.Generator) -> float:
    """
    Generate a Geometric Brownian Motion price

    Note: we automatically calculate dt as a
    fraction of the number steps 'N':  dt = 1/N

    Parameters:
        mu   : drift
        sigma: volatility
        rng  : random number generator
    Returns:
        the value as a float
    """
    # time as a factor of the total steps
    dt = 1.0 / num_steps
    return np.exp((mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * rng.normal())


if __name__ == "__main__":
    dex = DEX("./config.yaml")
    lp = dex.create_wallet()
    bob = dex.create_wallet()

    dex.pools.usdc_dai_100.mint_tokens(100_000, 100_000, lp)
    dex.pools.usdc_dai_100.mint_tokens(15000, 15000, bob)

    _, _, liq, _ = dex.pools.usdc_dai_100.mint_liquidity_position(
        10000, 10000, 0.97, 1.14, lp
    )
    assert liq > 0
    assert (1, 1) == dex.pools.usdc_dai_100.exchange_rates()

    steps = 50
    threshold = 0.01  # profit threshold...when we may arb...

    # external price configuration
    rng = np.random.default_rng(1234)
    volatility = 0.3
    mu = 0
    external_usdc_price = [gbm(mu, volatility, steps, rng) for _ in range(steps)]

    data = []
    for i in range(steps):
        # calculate the current DEX price
        dex_price_sqr96, _ = dex.pools.usdc_dai_100.get_sqrtp_tick()
        dex_price = sqrtp_to_price(dex_price_sqr96)

        # get the CEX price
        target_price = external_usdc_price[i]

        if target_price >= dex_price * (1 + threshold):
            # ~~~ possible arb opportunity ~~~
            # attempt to push the DEX price to the target price
            # this will swap (sell) token1 (DAI) for (buy) token0 (USDC)
            spent_token1, recv_token0 = dex.pools.usdc_dai_100.increase_price_of_token0(
                target_price, bob
            )

            # Get the new price after the swap
            c, _ = dex.pools.usdc_dai_100.get_sqrtp_tick()
            new_price = sqrtp_to_price(c)

            # what it we sold the USDC on the CEX...did we make money!?
            potential_profit = recv_token0 * target_price - spent_token1
            d = {
                "step": i,
                "cex_price": external_usdc_price[i],
                "initial_dex_price": dex_price,
                "final_dex_price": new_price,
                "bought": recv_token0,
                "spent": spent_token1,
                "profit_on_cex": potential_profit,
            }
            data.append(d)

    # note, the frame will only contain data for the arbs - not all steps
    print(pd.DataFrame(data))
